// Generated by CoffeeScript 2.4.1
(function() {
  var Speaker, StreamPlayer, audioOptions, base, base1, events, fs, lame, loadNextSong, request, self;

  Speaker = require('speaker');

  lame = require('lame');

  request = require('request');

  events = require('events');

  fs = require('fs');

  // http://stackoverflow.com/a/646643
  if ((base = String.prototype).startsWith == null) {
    base.startsWith = function(s) {
      return this.slice(0, s.length) === s;
    };
  }

  if ((base1 = String.prototype).endsWith == null) {
    base1.endsWith = function(s) {
      return s === '' || this.slice(-s.length) === s;
    };
  }

  audioOptions = {
    channels: 2,
    bitDepth: 16,
    sampleRate: 44100,
    mode: lame.STEREO
  };

  self = null;

  StreamPlayer = class StreamPlayer extends events.EventEmitter {
    constructor() {
      super();
      events.EventEmitter.call(this);
      self = this;
      this.queue = [];
      this.trackInfo = [];
      this.currentSong = null;
      this.playing = false;
      this.startTime = 0;
      this.speaker = null;
      this.decoder = null;
    }

    // Play the next song in the queue if it exists
    play() {
      if (this.currentSong !== null) {
        return this.resume();
      } else if (this.queue.length > 0 && !this.playing) {
        this.getStream(this.queue[0], this.playStream);
        this.playing = true;
        this.queue.shift();
        return this.currentSong = self.trackInfo.shift();
      } else if (this.playing) {
        return new Error('A song is already playing.');
      } else {
        return new Error('The queue is empty.');
      }
    }

    // Stop playing
    stop() {
      this.playing = false;
      this.currentSong = null;
      this.speaker.removeAllListeners('close');
      return this.speaker.end();
    }

    // Pause the current playing audio stream
    pause() {
      this.playing = false;
      this.speaker.removeAllListeners('close');
      return this.speaker.end();
    }

    // Pipe the decoded audio stream back to a speaker
    resume() {
      this.speaker = new Speaker(audioOptions);
      this.decoder.pipe(this.speaker);
      this.playing = true;
      return this.speaker.once('close', function() {
        return loadNextSong();
      });
    }

    // Remove a song with the given id metadata attribute
    remove(id) {
      var index;
      index = this.trackInfo.map(function(info) {
        return info.id;
      }).indexOf(parseInt(id, 10));
      this.trackInfo.splice(index, 1);
      return this.queue.splice(index, 1);
    }

    // Add a song and metadata to the queue
    add(url, track) {
      this.queue.push(url);
      this.trackInfo.push(track);
      return this.emit('song added', url, track);
    }

    // Returns the metadata for the song that is currently playing
    nowPlaying() {
      if (this.playing) {
        return {
          track: this.currentSong,
          timestamp: this.startTime
        };
      } else {
        throw new Error('No song is currently playing.');
      }
    }

    // Returns if there is a song currently playing
    isPlaying() {
      return this.playing;
    }

    // Returns the metadata for the songs that are in the queue
    getQueue() {
      return this.trackInfo;
    }

    // Get the audio stream
    getStream(url, callback) {
      var stream;
      if (url.startsWith('http')) {
        return request.get(url).on('response', function(res) {
          if (res.headers['content-type'] === 'audio/mpeg') {
            return callback(res);
          } else {
            self.emit('invalid url', url);
            return loadNextSong();
          }
        });
      } else {
        stream = fs.createReadStream(url);
        return callback(stream);
      }
    }

    // Decode the stream and pipe it to our speakers
    playStream(stream) {
      self.decoder = new lame.Decoder();
      self.speaker = new Speaker(audioOptions);
      return stream.pipe(self.decoder).once('format', function() {
        self.decoder.pipe(self.speaker);
        self.startTime = Date.now();
        self.emit('play start', self.currentSong);
        return self.speaker.once('close', function() {
          return loadNextSong();
        });
      });
    }

  };

  // Load the next song in the queue if there is one
  loadNextSong = function() {
    self.emit('play end', self.currentSong);
    self.currentSong = null;
    self.playing = false;
    return self.play();
  };

  module.exports = StreamPlayer;

}).call(this);
